M = abs(cor(training[-58]))
M = abs(cor(training[-58]))
diag(M) = 0
which(M>0.8, arr.ind=T)
M = abs(cor(training[,-58]))
diag(M) = 0
library(caret)
library(kernlab)
data(spam)
inTrain = createDataPartition(y=spam$type, p=0.75, list=FALSE)
training = spam[inTrain,]
testing = spam[-inTrain,]
M = abs(cor(training[,-58]))
diag(M) = 0
which(M>0.8, arr.ind=T)
names(spam)[c(34,32)]
plot(spam[,34],spam[,32])
X = 0.71*training$num415 + 0.71*training$num857
Y = 0.71*training$num415 - 0.71*training$num857
plot(X,Y)
plot(spam[,34],spam[,32])
plot(spam[,34],spam[,32])
X = 0.71*training$num415 + 0.71*training$num857
Y = 0.71*training$num415 - 0.71*training$num857
plot(X,Y)
library(shiny)
install.packages("shiny")
library(shiny)
runApp(C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products)
get.wd()
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
install.packages("UsingR")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
x=0
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
e
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\")
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\", display.mode='showcase')
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\", display.mode='showcase')
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\", display.mode='showcase')
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\", display.mode='showcase')
runApp("C:\\Users\\matthew.lanham\\Desktop\\Developing Data Products\\", display.mode='showcase')
library(manipulate)
manipulate(plot(1:x), x=slider(1,100))
library(manipulate)
myHist = function(mu) {
hist(galton$child, col='lightblue', breaks=100)
lines(c(mu,mu), c(0,150), col="red", lwd=5)
mse = mean((galton$child - mu)^2)
text(63, 150, paste("mu= ",mu))
text(63, 140, paste("MSE= ",round(mse,2)))
}
manipulate(myHist(mu), mu=slider(62,74,step=0.5))
library(manipulate)
myHist = function(mu) {
hist(galton$child, col='lightblue', breaks=100)
lines(c(mu,mu), c(0,150), col="red", lwd=5)
mse = mean((galton$child - mu)^2)
text(63, 150, paste("mu= ",mu))
text(63, 140, paste("MSE= ",round(mse,2)))
}
manipulate(myHist(mu), mu=slider(62,74,step=0.5))
library(manipulate)
myHist = function(mu) {
hist(galton$child, col='lightblue', breaks=100)
lines(c(mu,mu), c(0,150), col="red", lwd=5)
mse = mean((galton$child - mu)^2)
text(63, 150, paste("mu= ",mu))
text(63, 140, paste("MSE= ",round(mse,2)))
}
manipulate(myHist(mu), mu=slider(62,74,step=0.5))
library(UsingR)
library(UsingR)
library(manipulate)
#define your function
myHist = function(mu) {
hist(galton$child, col='lightblue', breaks=10)
lines(c(mu,mu), c(0,150), col="red", lwd=5)
mse = mean((galton$child - mu)^2)
text(63, 150, paste("mu= ",mu))
text(63, 140, paste("MSE= ",round(mse,2)))
}
#use manipluate to change the parameters of the function dynamically
manipulate(myHist(mu), mu=slider(62,74,step=0.5))
require(rCharts)
haireye = as.data.frame(HairEyeColor)
n1 = nPlot(Freq ~ Hair, group='Eye', type='multiBarChart'
, data=subset(haireye, Sex=='Male')
)
install_github('rCharts', 'ramnathv')
require(devtools)
install_github('rCharts', 'ramnathv')
require(rCharts)
setwd("C:/BADASS/Model_Mgmt/PART_TYPE_code")
library(caret)
library(kernlab)
data(spam)
# partition data set into training (75%) and testing (25%)
inTrain = createDataPartition(y=spam$type, p=0.75, list=FALSE)
head(inTrain)
training = spam[inTrain,]
testing = spam[-inTrain,]
dim(training)
##################
View(spam)
require(devtools)
install_github('rCharts', 'ramnathv')
require(rCharts)
haireye = as.data.frame(HairEyeColor)
n1 = nPlot(Freq ~ Hair, group='Eye', type='multiBarChart'
, data=subset(haireye, Sex=='Male')
)
n1
haireye = as.data.frame(HairEyeColor)
n1 = nPlot(Freq ~ Hair, group='Eye', type='multiBarChart'
, data=subset(haireye, Sex=='Male')
)
n1
library(caret)
library(kernlab)
data(spam)
inTrain = createDataPartition(y=spam$type, p=0.75, list=FALSE)
training = spam[inTrain,]
testing = spam[-inTrain,]
M = abs(cor(training[,-58]))
diag(M) = 0
which(M>0.8, arr.ind=T) #all predictors that have a correlation above 80%
which(M>0.85, arr.ind=T) #all predictors that have a correlation above 80%
names(spam)[c(34,32)]
plot(spam[,34],spam[,32])
plot(prComp$x[,1], prComp$x[,2])
smallSpam = spam[,c(34,32)]
prComp = prComp(smallSpam)
plot(prComp$x[,1], prComp$x[,2])
prComp = prComp(smallSpam)
library(caret)
library(kernlab)
prComp = prComp(smallSpam)
prComp = prcomp(smallSpam)  #prcomp comes from stats package
plot(prComp$x[,1], prComp$x[,2])
prComp$rotation                     #the PC rotation matrix
typeCOlor = ((spam$type=="spam")*1 + 1)
prComp = prcomp(log10(spam[,-58]+1))
prComp$rotation
plot(prComp$x[,1], prComp$x[,2], color=typeColor, xlab="PC1", ylab="PC2")
typeCOlor = ((spam$type=="spam")*1 + 1)
plot(prComp$x[,1], prComp$x[,2], color=typeColor, xlab="PC1", ylab="PC2")
typeCOlor = ((spam$type=="spam")*1 + 1)
prComp = prcomp(log10(spam[,-58]+1))
plot(prComp$x[,1], prComp$x[,2], color=typeColor, xlab="PC1", ylab="PC2")
typeColor = ((spam$type=="spam")*1 + 1)
plot(prComp$x[,1], prComp$x[,2], color=typeColor, xlab="PC1", ylab="PC2")
plot(prComp$x[,1], prComp$x[,2], col=typeColor, xlab="PC1", ylab="PC2")
typeColor
odbcDataSources()
library(RODBC)
odbcDataSources()
library(ROracle)
library(ROracle)
preProc = preProcess(log10(spam[,-58]+1), method="pca", pcaComp=2)
spamPC = predict(preProc, log10(spam[,-58]+1))
plot(spamPC[,1], spamPC[,2], col=typeColor)
preProc = preProcess(log10(training[,-58]+1), method="pca", pcaComp=2)
trainPC = predict(preProc, log10(training[,-58]+1))
trainPC
head(trainPC)
modelFit = train(training$type ~., method="glm", data=trainPC)
testPC = predict(preProc, log10(testing[,-58]+1))
head(testPC)
dim(testPC)
confusionMatrix(testing$type, predict(ModelFit, testPC))
preProc = preProcess(log10(training[,-58]+1), method="pca", pcaComp=2)
trainPC = predict(preProc, log10(training[,-58]+1))
head(trainPC)
modelFit = train(training$type ~., method="glm", data=trainPC)
testPC = predict(preProc, log10(testing[,-58]+1))
dim(testPC)
confusionMatrix(testing$type, predict(ModelFit, testPC))
confusionMatrix(testing$type, predict(modelFit, testPC))
preProc
modelFit = train(training$type ~., method="glm", preProcess="pca", data=training)
confusionMatrix(testing$type, predict(modelFit, testing))
library(caret)
data(faithful)
set.seed(333)
inTrain = createDataPartition(y=faithful$waiting, p=0.5, list=FALSE)
trainFaith = faithful[inTrain,]
testFaith = faithful[-inTrain,]
head(trainFaith)
plot(trainFaith$waiting, trainFaith$eruptions, pch=19, col="blue", xlab="waiting", ylab="duration")
lm1 = lm(eruptions ~ waiting, data=trainFaith)
summary(lm1)
plot(trainFaith$waiting, trainFaith$eruptions, pch=19, col="blue", xlab="waiting", ylab="duration")
lines(trainFaith$waiting, lm1$fitted, lw=4)
coef(lm1)[1] + coef(lm1)[2]*80
newdata = data.frame(waiting=80)
newdata
predict(lm1, newdata)
par(mfrow=c(1,2))
plot(trainFaith$waiting, trainFaith$eruptions, pch=19, col="blue", xlab="waiting", ylab="duration")
lines(trainFaith$waiting, lm1$fitted, lw=4)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue", xlab="waiting", ylab="duration")
lines(testFaith$waiting, predict(lm1, newdata=testFaith), lw=4)
par(mfrow=c(1,2))
plot(trainFaith$waiting, trainFaith$eruptions, pch=19, col="blue", xlab="waiting", ylab="duration", main="Training")
lines(trainFaith$waiting, lm1$fitted, lw=4)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue", xlab="waiting", ylab="duration", main="Testing")
lines(testFaith$waiting, predict(lm1, newdata=testFaith), lw=4)
sqrt(sum((lm$fitted - trainFaith$eruptions)^2))
sqrt(sum((lm1$fitted - trainFaith$eruptions)^2))
sqrt(sum((predict(lm1, newdata=testFaith) - testFaith$eruptions)^2))
pred1 = predict(lm1, newdata=testFaith, interval="prediction")
ord = order(testFaith$waiting)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue")
matlines(testFaith$waiting[ord], pred1[ord,], type="l",,col=c(1,2,2), lty=c(1,1,1), lwd=3)
par(mfrow=c(1,1))
pred1 = predict(lm1, newdata=testFaith, interval="prediction")
ord = order(testFaith$waiting)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue")
matlines(testFaith$waiting[ord], pred1[ord,], type="l",,col=c(1,2,2), lty=c(1,1,1), lwd=3)
modeFit = train(eruptions ~ waiting, data=trainFaith, method="lm")
summary(modFit$finalModel)
modFit = train(eruptions ~ waiting, data=trainFaith, method="lm")
summary(modFit$finalModel)
library(ISLR) #to get wage data
library(ggplot2)
library(caret)
data(Wage)
Wage = subset(Wage, select=-c(logwage))
summary(Wage)
data(Wage)
names(Wage)
Wage = subset(Wage, select=-c(logwage))
names(Wage)
inTrain = createDataPartition(Wage$wage, p=0.7, list=FALSE)
training=Wage[inTrain,]; testing=Wage[-inTrain,]
dim(training); dim(testing)
featurePlot(x=training[,c("age","eduction","jobclass")], y=train$Wage, plot="pairs")
featurePlot(x=training[,c("age","eduction","jobclass")], y=train$wage, plot="pairs")
featurePlot(x=training[,c("age","eduction","jobclass")], y=training$wage, plot="pairs")
featurePlot(x=training[,c("age","eduction","jobclass")], y=training$wage, plot="pairs")
featurePlot(x=training[,c("age","education","jobclass")], y=training$wage, plot="pairs")
qplot(age, wage, data=training)
qplot(age, wage, color=jobclass, data=training)
qplot(age, wage, color=education, data=training)
modFit = train(wage ~ age + jobclass + eduction, method="lm", data=training)
modFit = train(wage ~ age + jobclass + education, method="lm", data=training)
finMod = modFit$finalModel
print(modFit)
plot(finMod, 1, pch=19, cex=0.5, col="#000000010")
plot(finMod, 1, pch=19, cex=0.5, col="#00000010")
qplot(finMod$fitted, finMod$residuals, color=race, data=training)
plot(finMod$residuals, pch=19)
pred = predict(modFit, testing)
qplot(wage, pred, color=year, data=testing)
modFitAll = train(wage~., data=training, method="lm")
pred = predict(modFitAll, testing)
qplot(wage, pred, data=testing)
pred = predict(modFitAll, testing)
pred = predict(modFitAll , testing)
qplot(wage, pred, data=testing)
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
dData = data.frame(predictors)
head(dData)
names(dData)
adData = data.frame(predictors)
names(adData)
adData = data.frame(diagnosis,predictors)
names(adData)
View(adData)
adData = data.frame(diagnosis,predictors)
trainIndex = createDataPartition(diagnosis,p=0.5,list=FALSE)
trainIndex
training = adData[trainIndex,]
testing = adData[-trainIndex,]
dim(training)
dim(testing)
adData = data.frame(predictors)
trainIndex = createDataPartition(diagnosis,p=0.5,list=FALSE)
training = adData[trainIndex,]
dim(training)
testing = adData[-trainIndex,]
dim(testing)
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
names(concrete)
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
plot(training$CompressiveStrength, pch=19)
head(training)
plot(training$CompressiveStrength, pch=19)
plot(training$CompressiveStrength, color=Cement, pch=19)
plot(training$CompressiveStrength, color=training$Cement, pch=19)
cutCement = cut2(training$Cement, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, color=cutCement, pch=19)
library(Hmisc)
cutCement = cut2(training$Cement, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, color=cutCement, pch=19)
plot(training$CompressiveStrength, col=cutCement, pch=19)
head(concrete)
cutBlast = cut2(BlastFurnaceSlag, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutBlast, pch=19)
cutBlast = cut2(BlastFurnaceSlag, g=4) #g is based on quantile groups
cutBlast = cut2(training$BlastFurnaceSlag, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutBlast, pch=19)
plot(training$CompressiveStrength, col=training$FlyAsh, pch=19)
cutFlyAsh= cut2(training$FlyAsh, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutFlyAsh, pch=19)
cutWater= cut2(training$Water, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutWater, pch=19)
cutSuperplasticizer= cut2(training$Superplasticizer, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutSuperplasticizer, pch=19)
plot(training$CompressiveStrength, col=cutCoarseAggregate, pch=19)
cutCoarseAggregate= cut2(training$CoarseAggregate, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutCoarseAggregate, pch=19)
head(concrete)
cutFineAggregate= cut2(training$FineAggregate, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutFineAggregate, pch=19)
cutAge= cut2(training$Age, g=4) #g is based on quantile groups
plot(training$CompressiveStrength, col=cutAge, pch=19)
plot(training$CompressiveStrength, col=cutFlyAsh, pch=19)
plot(training$CompressiveStrength, col=cutAge, pch=19)
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
names(concrete)
hist(training$SuperPlasticizer)
head(concrete)
hist(training$SuperPlasticizer)
boxplot(training$SuperPlasticizer)
plot(training$SuperPlasticizer)
training$SuperPlasticizer
training$Superplasticizer
hist(training$Superplasticizer)
hist(log10(training$Superplasticizer))
hist(training$Superplasticizer)
hist(log10(training$Superplasticizer))
summary(training$Superplasticizer)
hist(log10(training$Superplasticizer)+1)
hist(training$Superplasticizer)
hist(log10(training$Superplasticizer))
hist(log10(training$Superplasticizer+1))
log(0)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
names(adData)
adData[which(names(adData)=="IL"),]
adData[,which(names(adData)=="IL")]
which(names(adData)=="IL")
names(adData)=="IL"
names(adData)
substr(names(adData),1,2)
substr(names(adData),1,2)=="IL"
adData[,which(substr(names(adData),1,2)=="IL")]
training = training[,which(substr(names(training),1,2)=="IL")]
names(training)
preProc = preProcess(log10(training[,]+1)
, method="pca")
log10(training[,]+1)
head(training)
preProc = preProcess(training
, method="pca")
objects(preProc)
summary(preProc)
preProc$numComp
preProc$pcaComp
objects(preProc)
preProc$ranges
preProc$knnSummary
preProc$yj
preProc$median
preProc$bc
preProc$std
objects(preProc)
preProc$thresh
summary(preProc)
preProc$rotation
test_pca = prcomp(training,
center = TRUE,
scale. = TRUE)
summary(test_pca)
head(training)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
training = training[,which(substr(names(training),1,2)=="IL")]
names(training)
head(training)
test_pca
testing = testing[,which(substr(names(testing),1,2)=="IL")]
predict(test_pca,
newdata=testing)
summary(test_pca)
preProc = preProcess(log10(training[,]+1), method="pca", pcaComp=7)
preProc
preProc = preProcess(training, method="pca", pcaComp=7)
preProc = preProcess(training, method="pca", pcaComp=7)
trainPC = predict(preProc, training)
head(trainPC)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
names(training)
testing = testing[,which(substr(names(testing),1,2)=="IL" | names(testing)=="diagnosis")]
training = training[,which(substr(names(training),1,2)=="IL"| names(testing)=="diagnosis")]
training = training[,which(substr(names(training),1,2)=="IL" | names(testing)=="diagnosis")]
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
training = training[,which(substr(names(training),1,2)=="IL" | names(training)=="diagnosis")]
testing = testing[,which(substr(names(testing),1,2)=="IL" | names(testing)=="diagnosis")]
names(training)
preProc = preProcess(training, method="pca", pcaComp=7)
dim(training)
dim(training)[2]
preProc = preProcess(training[,2:dim(training)[2]], method="pca", pcaComp=7)
trainPC = predict(preProc, training)
trainPC = predict(preProc, training[,2:dim(training)[2]])
head(trainPC)
names(training)
modelFit = train(training$diagnosis ~., method="glm", data=trainPC)
testPC = predict(preProc, testing[,2:dim(testing)[2]])
dim(testPC)
confusionMatrix(testing$diagnosis, predict(modelFit, testPC))
modelFit2 = train(training$diagnosis ~., method="glm", data=training)
testFit2 = predict(modelFit2, testing[,2:dim(testing)[2]])
confusionMatrix(testing$diagnosis, predict(modelFit2))
confusionMatrix(testing$diagnosis, testFit2)
library(knitr)
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
setwd("C:\\Users\\matthew.lanham\\RepData_PeerAssessment1")
knit2html("PA1_template.Rmd")  #To create a webpage
browseURL("PA1_template.html") #Opens webpage
